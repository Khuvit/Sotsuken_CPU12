================================================================================
MAJOR ARCHITECTURE CHANGES: From Original to Current rv32i.v (CPU10 to CPU12)
================================================================================

OVERVIEW:
The original design was a simple single-cycle CPU with hardcoded PC+4 increment.
The new design is a 5-stage pipeline with proper control flow support (branches, 
jumps) and multiple instruction types. Key improvements enable a real working RISC-V CPU.

================================================================================
CHANGE 1: DYNAMIC PC CALCULATION (Instead of Fixed PC+4)
================================================================================

ORIGINAL CODE:
    always @(posedge clk or negedge n_rst) begin
        if (!n_rst) begin
            pc_reg <= 0;
        end else begin
            pc_reg <= pc_reg + 8'd4;  // ALWAYS +4, no flexibility
        end
    end

NEW CODE (rv32i.v lines 32-41):
    wire [PC_W-1:0] pc_next;
    
    always @(posedge clk or negedge n_rst) begin
        if (!n_rst) begin
            pc_reg <= 0;
        end else begin
            pc_reg <= pc_next;  // Dynamic: can be +4, branch target, or jump target
        end
    end

WHY THIS CHANGE IS IMPORTANT:
- ORIGINAL PROBLEM: CPU always increments PC by 4, no support for branches/jumps
- NEW SOLUTION: pc_next is calculated dynamically based on instruction type
  * Default: PC+4 (sequential execution)
  * Branch taken: PC + branch_offset (conditional jumps)
  * JAL: PC + immediate offset (unconditional jump)
  * JALR: register + immediate offset (absolute jump)
- IMPACT: Enables proper control flow; without this, branch/jump code never works


================================================================================
CHANGE 2: COMPLETE IMMEDIATE DECODING
================================================================================

ORIGINAL CODE:
    wire    [IMM-1:0]       imm;
    wire    [19:0   ]       sext;
    ...
    assign sext     = {20{inst[31]}};
    assign imm      = {sext, funct7, rs2};  // Only one immediate format!

NEW CODE (rv32i.v lines 115-123):
    wire    [DATA_W-1:0]    imm_i, imm_s, imm_b, imm_j, imm_u;
    wire    [DATA_W-1:0]    imm_sel;
    
    assign imm_i = {{20{inst[31]}}, inst[31:20]};               // Load/IMM/JALR
    assign imm_s = {{20{inst[31]}}, inst[31:25], inst[11:7]};  // Store
    assign imm_b = {{19{inst[31]}}, inst[31], inst[7], inst[30:25], inst[11:8], 1'b0};  // Branch
    assign imm_j = {{11{inst[31]}}, inst[31], inst[19:12], inst[20], inst[30:21], 1'b0}; // JAL
    assign imm_u = {inst[31:12], 12'b0};                       // LUI/AUIPC
    
    assign imm_sel = (opcode == `OP_LOAD || opcode == `OP_IMM || opcode == `OP_JALR) ? imm_i :
                     (opcode == `OP_STORE) ? imm_s :
                     (opcode == `OP_BRANCH) ? imm_b :
                     (opcode == `OP_JAL) ? imm_j :
                     (opcode == `OP_LUI || opcode == `OP_AUIPC) ? imm_u :
                     imm_i;

WHY THIS CHANGE IS IMPORTANT:
- ORIGINAL PROBLEM: Only one immediate format; cannot handle store/branch/jump immediates
  The old format concatenates {sext, funct7, rs2} which is wrong for most instructions
- NEW SOLUTION: Decode all 5 immediate types per RISC-V spec:
  * imm_i: 12-bit sign-extended (load, arith-imm, JALR)
  * imm_s: 12-bit for store (different bit positions!)
  * imm_b: 13-bit for branch (includes left shift by 1)
  * imm_j: 21-bit for JAL (includes left shift by 1)
  * imm_u: 20-bit upper immediate (LUI/AUIPC)
- IMPACT: Without this, immediates are decoded incorrectly, breaking most instructions


================================================================================
CHANGE 3: EARLY JUMP DETECTION IN DECODE STAGE
================================================================================

ORIGINAL CODE:
    (No early detection; everything handled in Execute or later)

NEW CODE (rv32i.v lines 130-167):
    wire                    is_jal_D;       // Detect JAL in Decode
    wire                    is_jalr_D;      // Detect JALR in Decode
    wire    [PC_W-1:0]      jal_target_D;   // Pre-calculated jump target
    wire    [PC_W-1:0]      jalr_target_D;  // Pre-calculated JALR target
    wire    [DATA_W-1:0]    jal_sum_D;
    wire    [DATA_W-1:0]    jalr_sum_D;
    
    assign is_jal_D = (opcode == `OP_JAL);
    assign is_jalr_D = (opcode == `OP_JALR);
    assign jal_sum_D = pc_reg + imm_sel;
    assign jalr_sum_D = rdata1 + imm_sel;
    assign jal_target_D = jal_sum_D[PC_W-1:0];
    assign jalr_target_D = jalr_sum_D[PC_W-1:0];

WHY THIS CHANGE IS IMPORTANT:
- ORIGINAL PROBLEM: Jump targets computed in Execute stage → 1 cycle penalty
- NEW SOLUTION: Compute jump targets in Decode stage immediately
- IMPACT: Reduces jump latency by 1 cycle (pipelining optimization)
  JAL/JALR can now execute faster without stalling the pipeline


================================================================================
CHANGE 4: PC PIPELINE TRACKING
================================================================================

ORIGINAL CODE:
    (No PC registers in pipeline stages; only one pc_reg in Fetch)

NEW CODE (rv32i.v lines 96, 213, 211, 324-327):
    reg     [PC_W-1:0]      pc_E;      // PC value in Execute stage
    reg     [PC_W-1:0]      pc_M;      // PC value in Memory stage
    reg     [PC_W-1:0]      pc_W;      // PC value in Writeback stage
    
    always @(posedge clk) begin
        pc_E <= pc_reg;      // Capture current PC entering Execute
    end
    
    always @(posedge clk) begin
        pc_M <= pc_E;        // Pass PC to Memory stage
    end
    
    always @(posedge clk) begin
        pc_W <= pc_M;        // Pass PC to Writeback stage
    end

WHY THIS CHANGE IS IMPORTANT:
- ORIGINAL PROBLEM: No way to know original instruction's PC in later stages
- NEW SOLUTION: Pass PC through pipeline alongside instruction
- IMPACT: Needed for:
  * Branch target calculation (PC + branch_offset)
  * JAL/JALR return address (PC + 4)
  Without this, we can't implement branches or jumps correctly


================================================================================
CHANGE 5: BRANCH CONDITION EVALUATION IN EXECUTE
================================================================================

ORIGINAL CODE:
    assign beq      = (funct3_E == `OP_BEQ);
    assign bne      = (funct3_E == `OP_BNE);
    assign blt      = (funct3_E == `OP_BLT);
    assign bge      = (funct3_E == `OP_BGE);
    assign bltu     = (funct3_E == `OP_BLTU);
    assign bgeu     = (funct3_E == `OP_BGEU);
    (These wires detect instruction type but don't affect PC!)

NEW CODE (rv32i.v lines 240-269):
    assign branch_taken_E = (opcode_E == `OP_BRANCH) && 
                            (funct3_E == `OP_BEQ) && 
                            (rdata_E1 == rdata_E2);
    
    assign branch_sum = pc_E + imm_E;
    assign branch_target = branch_sum[7:0];
    
    always @(*) begin
        pc_next_r = pc_plus4;
        if (branch_taken_E)  pc_next_r = branch_target;
        if (is_jal_D)        pc_next_r = jal_target_D;
        if (is_jalr_D)       pc_next_r = jalr_target_D;
    end

WHY THIS CHANGE IS IMPORTANT:
- ORIGINAL PROBLEM: branch detection wires exist but aren't used to control PC
- NEW SOLUTION: Evaluate branch condition (rs1 == rs2 for BEQ) in Execute stage
  Then actually use the result to update PC via branch_target
- IMPACT: Branches now work! BEQ instruction can now jump to target address
  (Note: Only BEQ is currently implemented; BNE/BLT/BGE/BLTU/BGEU still need implementation)


================================================================================
CHANGE 6: SMART PC MULTIPLEXER WITH PRIORITY
================================================================================

ORIGINAL CODE:
    (No PC multiplexer; always use PC+4)

NEW CODE (rv32i.v lines 264-270):
    always @(*) begin
        pc_next_r = pc_plus4;                   // Default: PC+4
        if (branch_taken_E)  pc_next_r = branch_target;  // Override if branch
        if (is_jal_D)        pc_next_r = jal_target_D;   // Override if JAL
        if (is_jalr_D)       pc_next_r = jalr_target_D;  // Override if JALR (highest)
    end

WHY THIS CHANGE IS IMPORTANT:
- ORIGINAL PROBLEM: No way to choose between different PC paths
- NEW SOLUTION: Priority-based multiplexer:
  1. JALR (highest priority) - resolved in Decode, most direct jump
  2. JAL - unconditional jump, resolved in Decode
  3. Branch - conditional jump, resolved in Execute
  4. PC+4 (lowest priority, default) - normal sequential execution
- IMPACT: Ensures correct PC selection when multiple control changes could occur
  Prevents conflicts and ensures instruction coherence


================================================================================
CHANGE 7: JAL/JALR RETURN ADDRESS LINK
================================================================================

ORIGINAL CODE:
    assign wd = rd_data_W;  // Only write load data

NEW CODE (rv32i.v lines 337-377):
    wire [DATA_W-1:0] jal_link;
    
    assign jal_link = pc_W + 32'd4;  // Return address = PC of JAL/JALR + 4
    
    assign wd = (opcode_W == `OP_LOAD) ? rd_data_W :
                (opcode_W == `OP_OP || opcode_W == `OP_IMM || 
                 opcode_W == `OP_AUIPC || opcode_W == `OP_LUI) ? alu_res_W :
                (opcode_W == `OP_JAL || opcode_W == `OP_JALR) ? jal_link :
                rd_data_W;

WHY THIS CHANGE IS IMPORTANT:
- ORIGINAL PROBLEM: JAL/JALR instructions can't save return address
- NEW SOLUTION: Calculate return address as PC+4 and write to destination register
- IMPACT: Enables subroutine calls and returns
  When JAL x1, func_label executes:
  - Jump to func_label (via pc_next)
  - Save return address (current PC + 4) in x1 register
  - Function can later return via JALR x1


================================================================================
CHANGE 8: MULTI-SOURCE REGISTER WRITEBACK
================================================================================

ORIGINAL CODE:
    assign wd = rd_data_W;  // Only source: memory
    assign r_we = (opcode_W == `OP_LOAD);  // Only write on LOAD

NEW CODE (rv32i.v lines 360-377):
    assign wd = (opcode_W == `OP_LOAD) ? rd_data_W :
                (opcode_W == `OP_OP || opcode_W == `OP_IMM ||
                 opcode_W == `OP_AUIPC || opcode_W == `OP_LUI) ? alu_res_W :
                (opcode_W == `OP_JAL || opcode_W == `OP_JALR) ? jal_link :
                rd_data_W;
    
    assign r_we = (opcode_W == `OP_LOAD) || (opcode_W == `OP_OP) ||
                  (opcode_W == `OP_IMM) || (opcode_W == `OP_JAL) ||
                  (opcode_W == `OP_JALR) || (opcode_W == `OP_LUI) ||
                  (opcode_W == `OP_AUIPC);

WHY THIS CHANGE IS IMPORTANT:
- ORIGINAL PROBLEM: Can only write load data to registers; ALU results are lost!
- NEW SOLUTION: Multiplexer selects write data source:
  * LOAD: data from memory
  * OP/IMM: ALU result (ADD, SUB, AND, OR, XOR, SLL, SRL, SRA, etc.)
  * LUI/AUIPC: ALU result (upper immediate or PC+upper immediate)
  * JAL/JALR: return address (PC+4)
- IMPACT: All instruction types now write results correctly
  Without this, arithmetic operations (ADDI, ADD, etc.) execute but results are discarded


================================================================================
CHANGE 9: PROPER DATA MEMORY CONTROL SIGNALS
================================================================================

ORIGINAL CODE:
    (No explicit data memory control; wr_addr/d_out not properly driven)

NEW CODE (rv32i.v lines 400-413):
    assign wr_en = (opcode_M == `OP_STORE);
    assign mode = funct3_M[1:0];
    assign wr_addr = alu_res_M;
    assign d_out = rdata_M2;

WHY THIS CHANGE IS IMPORTANT:
- ORIGINAL PROBLEM: Store instructions don't have proper control logic
- NEW SOLUTION: Explicitly control memory writes:
  * wr_en: Enable write only for STORE instructions
  * mode: Use funct3 to determine store size (byte/half/word)
  * wr_addr: Write address from ALU (base address + offset)
  * d_out: Write data from rs2 register
- IMPACT: STORE instructions now work; memory writes are controlled properly


================================================================================
SUMMARY OF KEY IMPACTS
================================================================================

BEFORE (Original):
✗ PC always increments by 4 → no branches/jumps
✗ Immediate decoding wrong → load/store/branch/jump broken
✗ No PC pipeline → branch/jump targets can't be calculated
✗ Branch detection wires exist but don't control PC
✗ Only LOAD writes to registers → arithmetic results lost
✗ JAL/JALR can't save return addresses → no subroutine support

AFTER (Current):
✓ Dynamic PC control for branches, jumps, sequential execution
✓ Proper 5-type immediate decoding per RISC-V specification
✓ PC propagated through pipeline for correct target calculation
✓ Branch conditions evaluated and actually control PC
✓ Multiple instruction types can write register results
✓ JAL/JALR save return addresses for function calls
✓ Full 5-stage pipeline with proper stage separation
✓ Real working RISC-V CPU with control flow support

================================================================================

CPU12 improves functionality and software efficiency, but hardware clock speed depends on timing and may not increase.